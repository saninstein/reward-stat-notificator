from datetime import datetime

# Generated by CodiumAI

from app.notificator import Notificator
from app.services import NotificatorService


class TestNotificatorService:

    #  Service runs successfully and sends notification with daily $AIX stats
    def test_service_runs_successfully_and_sends_notification(self, mocker):
        # Mock the necessary dependencies
        mocker.patch('app.services.get_w3')
        mocker.patch('app.services.get_notificator')

        # Create a mock Distribution.get_day_statistic() that returns a valid dictionary
        mocker.patch('app.services.Distribution.get_day_statistic', return_value={
            'first_ts': datetime.utcnow(),
            'last_ts': datetime.utcnow(),
            'total_input_aix': 1000,
            'total_distributed_aix': 500,
            'total_swapped_eth': 10,
            'total_distributed_eth': 5,
            'distributors': ['address1', 'address2'],
        })

        # Create a mock Notificator.send_message() that does nothing
        mocker.patch.object(Notificator, 'send_message')

        # Create an instance of NotificatorService
        service = NotificatorService()

        service._init()

        service._w3.eth.get_balance = mocker.Mock(side_effect=lambda x: {'address1': 1e18, 'address2': 2*1e18}[x])

        # Run the service
        service._tick()

        # Assert that Notificator.send_message() was called with the correct message
        expected_message = """
        Daily $AIX Stats:
        - First TX: below 1s ago
        - Last TX: below 1s ago
        - AIX processed: 1,000.00
        - AIX distributed: 500.00
        - ETH bought: 10.00
        - ETH distributed: 5.00
        Distributors: address1 (1.00 ETH) address2 (2.00 ETH)
        """
        service._notificator.send_message.assert_called_once_with(expected_message)
